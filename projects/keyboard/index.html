<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚å®Ô∏è KEYBOARD HERO ¬∑ type & conquer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', 'Segoe UI', monospace, system-ui;
        }

        body {
            background: linear-gradient(145deg, #191e2e 0%, #0e1a26 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1.5rem;
        }

        .game-container {
            max-width: 1100px;
            width: 100%;
            background: rgba(20, 30, 45, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 2px solid #4f6e8a;
            border-radius: 3rem;
            padding: 2rem 2rem 2.5rem;
            box-shadow: 0 30px 50px #00000080, 0 0 0 2px #2d4b66 inset;
            color: #e0f2ff;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 1.8rem;
            border-bottom: 2px solid #3b5f7a;
            padding-bottom: 1rem;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 500;
            background: linear-gradient(135deg, #c0e0ff, #aad0ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header h1 span {
            background: #284a62;
            padding: 0.2rem 1.5rem;
            border-radius: 60px;
            font-size: 1.2rem;
            color: #d9f0ff;
            -webkit-text-fill-color: #e5f2ff;
            border: 1px solid #628bb0;
        }

        .score-panel {
            background: #142433;
            border-radius: 60px;
            padding: 0.5rem 1.8rem;
            border: 2px solid #4f7da3;
            font-weight: 600;
            display: flex;
            gap: 25px;
        }

        .score, .streak {
            font-size: 1.5rem;
            color: #f2e9c0;
        }

        .badge {
            font-size: 0.9rem;
            color: #b8d0e0;
        }

        /* main arena */
        .arena {
            background: #0e1a25;
            border-radius: 2.8rem;
            padding: 2rem 2rem 1rem;
            border: 2px solid #365f7e;
            box-shadow: inset 0 0 20px #00000070;
            margin-bottom: 2rem;
        }

        .target-line {
            background: #1f4057;
            border-radius: 60px;
            padding: 1rem 2rem;
            margin-bottom: 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border: 2px solid #6c9ec9;
            box-shadow: 0 0 15px #2f89d0;
        }

        .target-word {
            font-size: 3.2rem;
            font-weight: 700;
            font-family: 'Fira Mono', 'Courier New', monospace;
            letter-spacing: 4px;
            color: #fee7a0;
            text-shadow: 0 0 12px #f0b34b;
            background: #0a1b28;
            padding: 0.2rem 2rem;
            border-radius: 60px;
            border: 2px solid #b1a35b;
        }

        .word-flow {
            min-height: 200px;
            background: #0d1b27;
            border-radius: 2rem;
            padding: 1.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 18px 30px;
            justify-content: center;
            align-items: center;
            border: 2px solid #2a5377;
        }

        .falling-word {
            background: #1e3349;
            padding: 0.5rem 1.8rem;
            border-radius: 40px;
            font-size: 1.8rem;
            font-weight: 600;
            font-family: 'Fira Mono', monospace;
            color: #c2e0ff;
            border: 2px solid #5d84aa;
            box-shadow: 0 8px 0 #0b1925;
            transition: 0.1s;
            text-transform: lowercase;
        }

        .falling-word.matched {
            opacity: 0.3;
            border-color: #76b05e;
            box-shadow: 0 0 20px #84f068;
            transform: scale(0.9);
        }

        .input-area {
            display: flex;
            gap: 15px;
            align-items: center;
            background: #1d3142;
            border-radius: 60px;
            padding: 0.5rem 1rem 0.5rem 2rem;
            border: 2px solid #51799b;
        }

        #userInput {
            background: #0b1b2b;
            border: none;
            padding: 1.2rem 1.5rem;
            font-size: 1.8rem;
            font-family: 'Fira Mono', monospace;
            color: #e9ffd1;
            border-radius: 60px;
            width: 100%;
            outline: 2px solid #3a6285;
            text-transform: lowercase;
        }

        #userInput:focus {
            outline: 3px solid #7fb4e6;
            background: #0f2538;
        }

        .game-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1.5rem;
        }

        .btn {
            background: #223f58;
            border: none;
            color: white;
            font-size: 1.2rem;
            padding: 0.8rem 2.2rem;
            border-radius: 60px;
            font-weight: 600;
            cursor: pointer;
            border: 2px solid #70a5cf;
            transition: 0.1s;
        }

        .btn:hover {
            background: #2f5677;
            border-color: #a4d0ff;
            transform: scale(1.02);
        }

        .message {
            font-size: 1.2rem;
            background: #112436;
            padding: 0.5rem 2rem;
            border-radius: 40px;
            border: 1px solid #517ea0;
        }

        .danger {
            color: #ffb0a0;
        }
    </style>
</head>
<body>
<div class="game-container">
    <div class="header">
        <h1>‚å®Ô∏è KEYBOARD HERO <span>falling words</span></h1>
        <div class="score-panel">
            <div class="score">üíØ <span id="scoreDisplay">0</span></div>
            <div class="streak">‚ö° <span id="streakDisplay">0</span></div>
        </div>
    </div>

    <!-- main game arena -->
    <div class="arena">
        <div class="target-line">
            <span class="badge">üéØ type this</span>
            <span class="target-word" id="targetWord">start</span>
        </div>

        <div class="word-flow" id="wordFlow">
            <!-- falling words appear here -->
        </div>

        <div class="input-area">
            <input type="text" id="userInput" placeholder="type target here" autofocus>
        </div>
    </div>

    <div class="game-footer">
        <button class="btn" id="restartBtn">üîÑ restart</button>
        <div class="message" id="gameMessage">‚ú® match the falling word</div>
        <div class="message" id="timerMessage">‚è±Ô∏è 0.0s</div>
    </div>
</div>

<script>
    (function() {
        // ---------- GAME CONFIG ----------
        const wordBank = [
            'react', 'vue', 'angular', 'python', 'java', 'rust', 'go', 'swift',
            'kotlin', 'php', 'html', 'css', 'javascript', 'typescript', 'svelte',
            'django', 'flask', 'spring', 'laravel', 'unity', 'unreal', 'linux',
            'windows', 'apple', 'google', 'meta', 'amazon', 'netflix', 'spotify',
            'keyboard', 'hero', 'falling', 'words', 'type', 'fast', 'score',
            'combo', 'streak', 'reactor', 'compile', 'debug', 'code', 'stack'
        ];

        // state
        let activeWords = [];               // { id, text, matched }
        let targetWord = '';                // current target to type
        let score = 0;
        let streak = 0;
        let gameActive = true;
        let nextId = 0;
        let fallInterval = null;
        let spawnInterval = null;
        let startTime = null;               // performance timer
        let timerInterval = null;

        // DOM elements
        const targetSpan = document.getElementById('targetWord');
        const wordFlowDiv = document.getElementById('wordFlow');
        const userInput = document.getElementById('userInput');
        const scoreSpan = document.getElementById('scoreDisplay');
        const streakSpan = document.getElementById('streakDisplay');
        const gameMessage = document.getElementById('gameMessage');
        const timerMsg = document.getElementById('timerMessage');
        const restartBtn = document.getElementById('restartBtn');

        // helper: random word from bank
        function randomWord() {
            return wordBank[Math.floor(Math.random() * wordBank.length)];
        }

        // set a new random target (different from current maybe)
        function setRandomTarget() {
            let newTarget = randomWord();
            // avoid same target if possible but not critical
            targetWord = newTarget;
            targetSpan.innerText = targetWord;
        }

        // spawn a new falling word
        function spawnWord() {
            if (!gameActive) return;
            const wordText = randomWord();
            const id = nextId++;
            activeWords.push({ id, text: wordText, matched: false });
            renderFlow();
        }

        // mark a word as matched (by id)
        function matchWord(id) {
            const word = activeWords.find(w => w.id === id);
            if (word && !word.matched) {
                word.matched = true;

                // increase score, streak
                score += 10 + (streak * 2);
                streak += 1;
                updateScore();

                // remove after short delay (visual feedback)
                setTimeout(() => {
                    activeWords = activeWords.filter(w => w.id !== id);
                    renderFlow();
                }, 150);
                renderFlow(); // immediate for matched style
            }
        }

        // update score displays
        function updateScore() {
            scoreSpan.innerText = score;
            streakSpan.innerText = streak;
        }

        // render all falling words in flow
        function renderFlow() {
            if (!gameActive) {
                wordFlowDiv.innerHTML = '<div class="falling-word" style="background:#342b3f;">‚è∏Ô∏è game paused</div>';
                return;
            }

            if (activeWords.length === 0) {
                wordFlowDiv.innerHTML = '<div style="color:#708090; padding:1rem;">‚ú® words will appear...</div>';
                return;
            }

            let html = '';
            activeWords.forEach(w => {
                const matchedClass = w.matched ? 'matched' : '';
                html += `<div class="falling-word ${matchedClass}" data-id="${w.id}">${w.text}</div>`;
            });
            wordFlowDiv.innerHTML = html;
        }

        // check input against active words (only exact match to target)
        function handleTyping(e) {
            if (!gameActive) return;
            const input = userInput.value.trim().toLowerCase();
            if (input === '') return;

            // look for an unmatched word that equals input AND equals current target
            // target must match input, and the word must match target (basically same)
            const index = activeWords.findIndex(w => !w.matched && w.text === input && w.text === targetWord);
            if (index !== -1) {
                // match found
                const matchedId = activeWords[index].id;
                matchWord(matchedId);
                userInput.value = '';    // clear input
                // set new target
                setRandomTarget();
            } else {
                // wrong input: reset streak, show message
                if (input.length > 0) {
                    streak = 0;
                    updateScore();
                    gameMessage.innerText = '‚ùå mismatch ... streak lost';
                    setTimeout(() => gameMessage.innerText = '‚ú® keep typing', 800);
                }
                userInput.value = ''; // clear for next try
            }
        }

        // restart / reset game fully
        function resetGame() {
            // clear intervals
            if (fallInterval) clearInterval(fallInterval);
            if (spawnInterval) clearInterval(spawnInterval);
            if (timerInterval) clearInterval(timerInterval);

            // reset state
            activeWords = [];
            score = 0;
            streak = 0;
            nextId = 0;
            gameActive = true;
            setRandomTarget();
            updateScore();
            userInput.value = '';
            gameMessage.innerText = '‚ö° game restarted';
            renderFlow();

            // restart intervals
            spawnInterval = setInterval(() => {
                if (gameActive) spawnWord();
            }, 1500); // new word every 1.5 sec

            fallInterval = setInterval(() => {
                // remove oldest word if too many? optional: simulate fall removal (we remove after time)
                if (!gameActive) return;
                if (activeWords.length > 8) {
                    // remove first unmatched (oldest) as "missed"
                    const oldestUnmatched = activeWords.find(w => !w.matched);
                    if (oldestUnmatched) {
                        activeWords = activeWords.filter(w => w.id !== oldestUnmatched.id);
                        streak = 0;
                        updateScore();
                        gameMessage.innerText = 'üíî word missed ...';
                        setTimeout(() => gameMessage.innerText = '‚å®Ô∏è stay focused', 700);
                        renderFlow();
                    }
                }
                // also randomly remove some after long time? but we keep manageable
                // every 4 sec, remove a random unmatched if too many
                if (activeWords.length > 12) {
                    const unmatchedIndices = activeWords.reduce((acc, w, idx) => !w.matched ? acc.concat(idx) : acc, []);
                    if (unmatchedIndices.length > 0) {
                        const randIdx = unmatchedIndices[Math.floor(Math.random() * unmatchedIndices.length)];
                        activeWords.splice(randIdx, 1);
                        renderFlow();
                    }
                }
            }, 2000);

            // timer
            startTime = performance.now();
            timerInterval = setInterval(() => {
                if (!gameActive) return;
                const elapsed = (performance.now() - startTime) / 1000;
                timerMsg.innerText = `‚è±Ô∏è ${elapsed.toFixed(1)}s`;
            }, 100);
        }

        // event listeners
        userInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleTyping(e);
            }
        });

        // also handle input event for immediate check (optional)
        userInput.addEventListener('input', (e) => {
            // we only check on enter, but we can also check if we want instant? we stick to enter.
        });

        restartBtn.addEventListener('click', () => {
            resetGame();
        });

        // initial reset to start
        resetGame();

        // blur prevention: keep focus
        userInput.focus();
        document.addEventListener('click', () => userInput.focus());

        // pause if game inactive (but we keep running)
        window.addEventListener('load', () => userInput.focus());

        // make sure target appears from beginning
        setRandomTarget();
    })();
</script>
</body>
</html>