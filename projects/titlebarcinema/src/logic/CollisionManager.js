/**
 * TitleBarCinema - CollisionManager.js
 * 
 * ============================================================================
 * ARCHITECTURAL OVERVIEW
 * ============================================================================
 * The CollisionManager orchestrates the interaction layer of the engine. 
 * While the PhysicsEngine provides the raw mathematical "hit" detection, 
 * this manager determines the "consequences" of those hits within 
 * the game's business logic.
 * 
 * It monitors the relationship between the player entity and the list of 
 * active obstacles generated by the WorldManager. Upon detecting a 
 * collision, it triggers the necessary state changes (e.g., life deduction, 
 * animations, or game-over sequences).
 * 
 * ============================================================================
 * MODULE METADATA
 * ============================================================================
 * @project TitleBarCinema
 * @module Logic.CollisionManager
 * @version 1.0.0
 * @author Antigravity
 */

/**
 * @class CollisionManager
 * @description Master controller for entity interaction and hit resolution.
 */
export class CollisionManager {
    /**
     * @constructor
     * @param {PhysicsEngine} physicsEngine - Reference to the core physics calculator.
     */
    constructor(physicsEngine) {
        /** @private @type {PhysicsEngine} The mathematical backend */
        this.physics = physicsEngine;

        /** 
         * @private @type {Function|null} 
         * Callback function invoked when the player hits an obstacle.
         */
        this.onCollision = null;
    }

    /**
     * Iterates through all active obstacles to check for a player impact.
     * This is an O(n) check where n is the number of simultaneous obstacles.
     * 
     * @param {Entity} player - The protagonist character entity.
     * @param {Array<Entity>} obstacles - The list of active threats.
     * @returns {void}
     */
    checkPlayerCollisions(player, obstacles) {
        // Optimization: If player is already dead or in a grace period, skip checks
        if (!player.isAlive) return;

        for (const obstacle of obstacles) {
            // Ask the physics engine for a mathematical overlap check
            if (this.physics.checkCollision(player, obstacle)) {
                // Resolution Logic
                this.handleCollision(player, obstacle);
                break; // Exit early after first hit detected
            }
        }
    }

    /**
     * Resolves the aftermath of a confirmed collision.
     * Updates player flags and triggers registered event listeners.
     * 
     * @param {Entity} player - The protagonist.
     * @param {Entity} obstacle - The entity that was hit.
     * @returns {void}
     */
    handleCollision(player, obstacle) {
        // 1. Update State
        player.isAlive = false;

        // 2. Apply Visual Physics Death-Pop
        player.velocityX = 0;
        player.velocityY = -2;

        // 3. Notify System
        if (this.onCollision) {
            this.onCollision(obstacle);
        }
    }

    /**
     * Registers a listener to be notified when a collision event occurs.
     * This is typically used by the main engine to trigger Game Over states.
     * 
     * @param {Function} callback - Function to execute on hit.
     * @returns {void}
     */
    setCollisionListener(callback) {
        this.onCollision = callback;
    }

    /**
     * Utility method to determine if a specific point is inside an entity.
     * Reserved for mouse-interaction features.
     * @param {number} x - Target horizontal coordinate.
     * @param {Entity} entity - Target object.
     * @returns {boolean}
     */
    pointInEntity(x, entity) {
        return x >= entity.x && x < entity.x + entity.width;
    }
}
