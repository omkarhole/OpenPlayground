<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D QR Code Generator</title>
</head>
<style>
            /* Body background is set to a dark gray just to demonstrate transparency, 
           but the canvas itself is transparent. */
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: sans-serif; }
        canvas { display: block; }
        .lil-gui.root { position: absolute; bottom: 20px; right: 20px; top: auto !important; }
</style>
<body>
        <!-- Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js",
                "qrcode": "https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"
            }
        }
    </script>
    <script src="https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"></script>
    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import GUI from 'lil-gui';

    // ==========================================
    // USER CONFIGURATION
    // in mode set URL Link or vCard
    // ==========================================
    const USER_DEFAULTS = {
        mode: 'URL Link', 
        url: 'https://portfolio-gamma-smoky-11.vercel.app/',
        vName: 'Omkar',
        vEmail: 'omkarhole314@gmail.com',
        vPhone1: '+7 708 9635525',
        vPhone2: '',
        vWeb: 'https://portfolio-gamma-smoky-11.vercel.app/',
        cutScale: 0.450,
        border: false // Default border state
    };

    // --- 1. Scene Setup ---
    const scene = new THREE.Scene();
    scene.background = null; 

    const camera = new THREE.PerspectiveCamera(18, window.innerWidth / window.innerHeight, 10, 1000);
    camera.position.set(100, -30, 100);

    const renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true, 
        logarithmicDepthBuffer: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.setClearColor(0x000000, 0); 
    document.body.appendChild(renderer.domElement);

    // --- 2. Lighting ---
    new RGBELoader()
        .setPath('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/2k/')
        .load('brown_photostudio_02_2k.hdr', function (texture) {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false; 
            scene.environment = texture;
        });

    const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
    dirLight.position.set(15, 20, 15);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.bias = -0.0005;
    dirLight.shadow.normalBias = 0.02;
    scene.add(dirLight);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true; 
    controls.autoRotateSpeed = 1.0;

    // --- Global var to store current QR data for texture updates ---
    let currentQR = null; 

    // --- 3. Texture Generation ---

    // A. MASKED Fine Noise (Combines Dust + QR Pattern + Border Logic)
    function createMaskedFineNoiseTexture(density = 1.0, qrData = null, useBorder = false) {
        const size = 1024; 
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        ctx.clearRect(0, 0, size, size);

        if (!qrData) return new THREE.CanvasTexture(canvas);

        const rawCount = qrData.getModuleCount();
        const borderOffset = useBorder ? 1 : 0; // 1 module frame
        const totalCount = rawCount + (borderOffset * 2);
        
        const modulePx = size / totalCount;

        // 3. Draw Noise Everywhere first
        const imageData = ctx.createImageData(size, size);
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            if (Math.random() > (1.0 - (density * 0.5))) {
                const alpha = Math.random() * 150; 
                data[i] = 255;     
                data[i+1] = 255;   
                data[i+2] = 255;   
                data[i+3] = alpha; 
            } else {
                data[i+3] = 0;
            }
        }
        ctx.putImageData(imageData, 0, 0);

        // 4. MASKING PASS: Punch holes where QR is black
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = 'black'; 

        for (let r = 0; r < rawCount; r++) {
            for (let c = 0; c < rawCount; c++) {
                if (qrData.isDark(r, c)) {
                    // Shift drawing coordinates if border is active
                    const drawC = c + borderOffset;
                    const drawR = r + borderOffset;
                    
                    ctx.fillRect(drawC * modulePx, drawR * modulePx, modulePx, modulePx);
                }
            }
        }

        ctx.globalCompositeOperation = 'source-over';

        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
        return tex;
    }

// B. Sharp Cracks / Cuts Generation (With Masking)
    function createVeinsTexture(scale = 1.0, qrData = null, useBorder = false) {
        const size = 1024; 
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        ctx.clearRect(0, 0, size, size);
        
        // --- 1. SHARP DRAWING SETTINGS ---
        // 'butt' makes ends flat/sharp
        // 'miter' makes connections pointy instead of round
        ctx.lineCap = 'butt'; 
        ctx.lineJoin = 'miter';
        ctx.miterLimit = 4; // Controls how spikey the corners can get
        ctx.strokeStyle = '#FFFFFF'; 

        function drawCrack(x, y, angle, width, life) {
            // Stop if too thin or dead
            if (life <= 0 || width < 0.2) return;

            // Segments are shorter and distinct for a "shattered" look
            const segmentLength = 5 + Math.random() * 15;

            const x2 = x + Math.cos(angle) * segmentLength;
            const y2 = y + Math.sin(angle) * segmentLength;

            ctx.beginPath();
            ctx.lineWidth = width;
            ctx.moveTo(x, y);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            // --- JAGGED MOVEMENT ---
            // Sharp deviations instead of smooth curves
            // Randomly deviate by ~45-80 degrees left or right
            const jaggedness = (Math.random() - 0.5) * 1.5; 
            const newAngle = angle + jaggedness;

            // Taper width faster (0.92) to make sharp tips
            const newWidth = width * 0.92; 
            const newLife = life - 1;

            drawCrack(x2, y2, newAngle, newWidth, newLife);

            // --- SHARP BRANCHING ---
            if (Math.random() < 0.08) { // 8% chance to split
                // Split direction creates a 'V' shape or broken glass look
                const splitDir = Math.random() < 0.5 ? -1 : 1;
                const splitAngle = angle + (splitDir * (0.4 + Math.random() * 0.5)); 
                drawCrack(x2, y2, splitAngle, newWidth * 0.7, newLife * 0.7);
            }
        }

        const rootsCount = 15 * scale;
        
        for (let i = 0; i < rootsCount; i++) {
            const startX = Math.random() * size;
            const startY = Math.random() * size;
            const startAngle = Math.random() * Math.PI * 2;
            
            // Start slightly thinner for sharper look
            const startWidth = (Math.random() * 3 + 1) * scale; 
            
            drawCrack(startX, startY, startAngle, startWidth, 50); 
        }

        // --- 2. MASKING PASS (Remove cracks over holes) ---
        if (qrData) {
            const rawCount = qrData.getModuleCount();
            const borderOffset = useBorder ? 1 : 0;
            const totalCount = rawCount + (borderOffset * 2);
            const modulePx = size / totalCount;

            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'black'; 

            for (let r = 0; r < rawCount; r++) {
                for (let c = 0; c < rawCount; c++) {
                    if (qrData.isDark(r, c)) {
                        const drawC = c + borderOffset;
                        const drawR = r + borderOffset;
                        ctx.fillRect(drawC * modulePx, drawR * modulePx, modulePx, modulePx);
                    }
                }
            }
            ctx.globalCompositeOperation = 'source-over';
        }

        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
        return tex;
    }

    // Initial Placeholder Texture
    let texFine = createMaskedFineNoiseTexture(0.5, null, USER_DEFAULTS.border);

    // --- 4. Materials ---
    const qrGroup = new THREE.Group();
    scene.add(qrGroup);

    const materialMetal = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 1.0,
        roughness: 0.05, 
    });

    const materialSide = new THREE.MeshStandardMaterial({
        color: 0x050505, 
        metalness: 0.3,  
        roughness: 0.8   
    });

    const materialBase = new THREE.MeshStandardMaterial({
        color: 0x050505, 
        metalness: 0.1,
        roughness: 0.8,
    });

    const materialOverlayFine = new THREE.MeshBasicMaterial({
        color: 0x000000, 
        alphaMap: texFine,
        transparent: true,
        opacity: 0.4, 
        side: THREE.DoubleSide,
        depthWrite: false, 
        blending: THREE.NormalBlending,
        polygonOffset: true,
        polygonOffsetFactor: -1,
        polygonOffsetUnits: -1
    });

    const veinsMaterials = [];
    function initVeinsMaterials() {
        veinsMaterials.length = 0;
        for (let i = 0; i < 6; i++) {
            const tex = createVeinsTexture(USER_DEFAULTS.cutScale); 
            const mat = new THREE.MeshBasicMaterial({
                color: 0x000000, 
                alphaMap: tex,
                transparent: true, 
                opacity: 1.0, 
                alphaTest: 0.5, 
                side: THREE.DoubleSide,
                depthWrite: true 
            });
            veinsMaterials.push(mat);
        }
    }
    initVeinsMaterials();

    // --- 5. Logic ---
    const params = {
        mode: USER_DEFAULTS.mode,
        url: USER_DEFAULTS.url,
        vName: USER_DEFAULTS.vName,
        vEmail: USER_DEFAULTS.vEmail,
        vPhone1: USER_DEFAULTS.vPhone1,
        vPhone2: USER_DEFAULTS.vPhone2,
        vWeb: USER_DEFAULTS.vWeb,
        baseSize: 20,
        layerDepth: 1.0,
        fineOpacity: 0.4,
        fineDensity: 0.5,
        cutScale: USER_DEFAULTS.cutScale,
        cutThreshold: 0.5,
        metalness: 1.0,
        roughness: 0.05,
        rotate: true,
        border: USER_DEFAULTS.border // Parameter for the frame
    };

    function generateQR() {
        while(qrGroup.children.length > 0){
            const obj = qrGroup.children[0];
            if (obj.geometry) obj.geometry.dispose();
            qrGroup.remove(obj);
        }

        const qr = qrcode(0, 'L');
        currentQR = qr; 

        try {
            let stringToEncode = "";
            if (params.mode === 'URL Link') {
                stringToEncode = params.url;
            } else {
                stringToEncode = `BEGIN:VCARD\nVERSION:3.0\n`;
                if(params.vName) stringToEncode += `FN:${params.vName}\n`;
                if(params.vEmail) stringToEncode += `EMAIL:${params.vEmail}\n`;
                if(params.vPhone1) stringToEncode += `TEL;TYPE=CELL:${params.vPhone1}\n`;
                if(params.vPhone2) stringToEncode += `TEL;TYPE=WORK:${params.vPhone2}\n`;
                if(params.vWeb) stringToEncode += `URL:${params.vWeb}\n`;
                stringToEncode += `END:VCARD`;
            }
            qr.addData(stringToEncode);
            qr.make();
        } catch (e) { 
            console.warn("Data too long for QR code version");
            return; 
        }

        // Update texture with new border setting
        updateFineTexture();
        updateAllVeinsTextures(); 

        const rawCount = qr.getModuleCount();
        
        // --- BORDER LOGIC ---
        const borderOffset = params.border ? 1 : 0; // 1 module thickness
        const totalCount = rawCount + (borderOffset * 2);
        
        // Adjust module size so the total cube fits in baseSize
        const moduleSize = params.baseSize / totalCount;

        // 1. Base Cube (Black Inner)
        const baseGeometry = new THREE.BoxGeometry(params.baseSize, params.baseSize, params.baseSize);
        const baseCube = new THREE.Mesh(baseGeometry, materialBase);
        baseCube.castShadow = true;
        baseCube.receiveShadow = true;
        qrGroup.add(baseCube);

        // 2. Base Cube Dust (Inner Layer)
        const baseDustGeo = new THREE.BoxGeometry(params.baseSize + 0.01, params.baseSize + 0.01, params.baseSize + 0.01);
        const baseDust = new THREE.Mesh(baseDustGeo, materialOverlayFine);
        qrGroup.add(baseDust);

        // 3. Metal Tiles
        const tileSize = moduleSize * 1.02; 
        const blockGeometry = new THREE.BoxGeometry(tileSize, tileSize, params.layerDepth);
        
        let metalTilesCount = 0;
        
        // Calculate total tiles including border
        for (let r = 0; r < totalCount; r++) {
            for (let c = 0; c < totalCount; c++) {
                // If in border zone -> It's a Metal Tile
                if (r < borderOffset || r >= totalCount - borderOffset ||
                    c < borderOffset || c >= totalCount - borderOffset) {
                    metalTilesCount++;
                } else {
                    // Inside QR area
                    const qrR = r - borderOffset;
                    const qrC = c - borderOffset;
                    // !isDark = White = Metal
                    if (!qr.isDark(qrR, qrC)) metalTilesCount++;
                }
            }
        }
      
        const materialsList = [
            materialSide, materialSide, materialSide, materialSide,
            materialMetal, 
            materialSide   
        ];
        
        const totalInstances = metalTilesCount * 6; 
        const meshInstanced = new THREE.InstancedMesh(blockGeometry, materialsList, totalInstances);
        const dummy = new THREE.Object3D();
        let idx = 0;
        const surfaceDist = (params.baseSize / 2) + (params.layerDepth / 2);

        for (let face = 0; face < 6; face++) {
            for (let r = 0; r < totalCount; r++) {
                for (let c = 0; c < totalCount; c++) {
                    
                    let isMetal = false;

                    // Check Border
                    if (r < borderOffset || r >= totalCount - borderOffset ||
                        c < borderOffset || c >= totalCount - borderOffset) {
                        isMetal = true; 
                    } else {
                        // Check QR Data
                        const qrR = r - borderOffset;
                        const qrC = c - borderOffset;
                        if (!qr.isDark(qrR, qrC)) isMetal = true;
                    }

                    if (isMetal) {
                        const u = (c - totalCount / 2 + 0.5) * moduleSize;
                        const v = -(r - totalCount / 2 + 0.5) * moduleSize;
                        
                        dummy.rotation.set(0, 0, 0);
                        switch(face) {
                            case 0: dummy.position.set(u, v, surfaceDist); break;
                            case 1: dummy.position.set(-u, v, -surfaceDist); dummy.rotation.y = Math.PI; break;
                            case 2: dummy.position.set(u, surfaceDist, -v); dummy.rotation.x = -Math.PI / 2; break;
                            case 3: dummy.position.set(u, -surfaceDist, v); dummy.rotation.x = Math.PI / 2; break;
                            case 4: dummy.position.set(surfaceDist, v, -u); dummy.rotation.y = Math.PI / 2; break;
                            case 5: dummy.position.set(-surfaceDist, v, u); dummy.rotation.y = -Math.PI / 2; break;
                        }
                        dummy.updateMatrix();
                        meshInstanced.setMatrixAt(idx++, dummy.matrix);
                    }
                }
            }
        }
        meshInstanced.castShadow = true;
        meshInstanced.receiveShadow = true;
        qrGroup.add(meshInstanced);

        // --- SHARED GEOMETRY FOR OVERLAYS ---
        const overlayPlaneGeo = new THREE.PlaneGeometry(params.baseSize, params.baseSize);

        // 4. Outer Dust Overlay (Group of 6 Planes)
        const dustGroup = new THREE.Group();
        const dustDist = (params.baseSize / 2) + params.layerDepth + 0.005;

        for (let i = 0; i < 6; i++) {
            const mesh = new THREE.Mesh(overlayPlaneGeo, materialOverlayFine);
            switch(i) {
                case 0: mesh.position.z = dustDist; break;
                case 1: mesh.position.z = -dustDist; mesh.rotation.y = Math.PI; break;
                case 2: mesh.position.y = dustDist; mesh.rotation.x = -Math.PI / 2; break;
                case 3: mesh.position.y = -dustDist; mesh.rotation.x = Math.PI / 2; break;
                case 4: mesh.position.x = dustDist; mesh.rotation.y = Math.PI / 2; break;
                case 5: mesh.position.x = -dustDist; mesh.rotation.y = -Math.PI / 2; break;
            }
            dustGroup.add(mesh);
        }
        qrGroup.add(dustGroup);

        // 5. Veins / Cuts Overlay (Group of 6 Planes)
        const cutsGroup = new THREE.Group();
        const cutDist = (params.baseSize / 2) + params.layerDepth + 0.01;

        for (let i = 0; i < 6; i++) {
            const mesh = new THREE.Mesh(overlayPlaneGeo, veinsMaterials[i]);
            switch(i) {
                case 0: mesh.position.z = cutDist; break;
                case 1: mesh.position.z = -cutDist; mesh.rotation.y = Math.PI; break;
                case 2: mesh.position.y = cutDist; mesh.rotation.x = -Math.PI / 2; break;
                case 3: mesh.position.y = -cutDist; mesh.rotation.x = Math.PI / 2; break;
                case 4: mesh.position.x = cutDist; mesh.rotation.y = Math.PI / 2; break;
                case 5: mesh.position.x = -cutDist; mesh.rotation.y = -Math.PI / 2; break;
            }
            cutsGroup.add(mesh);
        }
        qrGroup.add(cutsGroup);
    }

    function updateFineTexture() {
        texFine = createMaskedFineNoiseTexture(params.fineDensity, currentQR, params.border);
        materialOverlayFine.alphaMap = texFine;
        materialOverlayFine.needsUpdate = true;
    }

function updateAllVeinsTextures() {
        veinsMaterials.forEach(mat => {
            if (mat.alphaMap) mat.alphaMap.dispose();
            // Pass currentQR and border param
            mat.alphaMap = createVeinsTexture(params.cutScale, currentQR, params.border);
            mat.needsUpdate = true;
        });
    }

    // --- 6. GUI Settings ---
    const gui = new GUI({ title: 'QR Settings' });
    
    gui.add(params, 'mode', ['URL Link', 'vCard']).name('QR Type').onChange(value => {
        updateGuiVisibility(value);
        generateQR();
    });

    const folderUrl = gui.addFolder('URL Data');
    folderUrl.add(params, 'url').name('Link').onFinishChange(generateQR);

    const folderVCard = gui.addFolder('vCard Data');
    folderVCard.add(params, 'vName').name('Full Name').onFinishChange(generateQR);
    folderVCard.add(params, 'vEmail').name('Email').onFinishChange(generateQR);
    folderVCard.add(params, 'vPhone1').name('Phone 1').onFinishChange(generateQR);
    folderVCard.add(params, 'vPhone2').name('Phone 2').onFinishChange(generateQR);
    folderVCard.add(params, 'vWeb').name('Website').onFinishChange(generateQR);

    function updateGuiVisibility(mode) {
        if (mode === 'URL Link') {
            folderUrl.show();
            folderVCard.hide();
        } else {
            folderUrl.hide();
            folderVCard.show();
        }
    }
    
    gui.add(params, 'rotate').name('Auto Rotation').onChange(v => controls.autoRotate = v);
    
    const fGeo = gui.addFolder('Geometry');
    fGeo.add(params, 'border').name('Quiet Zone (Frame)').onChange(generateQR); // Toggle Frame
    fGeo.add(params, 'layerDepth', 0.01, 1).name('Layer Depth').onChange(generateQR);

    const fFine = gui.addFolder('Layer: Dust (Fine)');
    fFine.add(params, 'fineOpacity', 0, 1).name('Opacity').onChange(v => materialOverlayFine.opacity = v);
    fFine.add(params, 'fineDensity', 0.1, 2.0).name('Density').onChange(updateFineTexture);

    const fVeins = gui.addFolder('Layer: Cracks (Cuts)');
    fVeins.add(params, 'cutScale', 0.1, 3.0).name('Scale/Frequency').onChange(updateAllVeinsTextures);
    fVeins.add(params, 'cutThreshold', 0.0, 0.9).name('Cut Width').onChange(v => {
        veinsMaterials.forEach(mat => {
            mat.alphaTest = v;
            mat.needsUpdate = true;
        });
    });

    const fMat = gui.addFolder('Materials (Base)');
    fMat.add(params, 'metalness', 0, 1).name('Metalness').onChange(v => materialMetal.metalness = v);
    fMat.add(params, 'roughness', 0, 1).name('Roughness').onChange(v => materialMetal.roughness = v);

    updateGuiVisibility(params.mode);
    generateQR();

    // --- 7. Animation ---
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
    </script>
</body>
</html>